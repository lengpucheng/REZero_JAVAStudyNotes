集合作为数组的一种替换对象，可以像数组一样对多个对象和数据进行操作，其可以**动态开辟内存空间**，对数据进行一些检验，并提供更多的常用方法。（在**内存中数组是连续的内存空间**，并且具有顺序性）



# 一、集合接口

在JAVA中集合有两套**接口**体系`Collection`和`Map`：

+ `Collection`：**一组数据的容器**，定义了存取一组对象的方法
  + `List`：**有序、可重复**数据集，类似于**动态数组**
  + `Set`：**无序、不可重复**数据集
+ `Map`：**双列数据的容器**，保存具有映射关系的`key-value`键值对

## 1. Collection体系

![image-20210302142527448](C:\Users\lpc\Desktop\笔记\JAVA01-进阶\images\image-20210302142527448.png)

## 2. Map体系

![image-20210302142549630](C:\Users\lpc\Desktop\笔记\JAVA01-进阶\images\image-20210302142549630.png)



# 二、Collection接口

## 1. 通用方法

| 方法               | 含义       | 描述                                                         |
| ------------------ | ---------- | ------------------------------------------------------------ |
| A.add(O o)         | **添加**   | 向集合A中添加一个元素o，成功返回true                         |
| A.addAll(C c)      | 添加集合   | 向集合A中添加**集合c**中**全部元素**，成功返回true           |
| A.clear()          | 清空       | 清空集合A中全部元素                                          |
| A.size()           | **大小**   | 返回集合A中**元素个数**                                      |
| A.isEmpty()        | 判空       | 判断集合A中元素**个数是否为0**                               |
| A.contains(O o)    | **包含**   | 判断集合A中**是否包含**元素o（**判断内容，调用的是o.equals方法**） |
| A.containsAll(C c) | 包含集合   | 判断集合A中是**否包含集合**c的**全部元素**（**不要求顺序**） |
| A.remove(O o)      | **移除**   | 移除集合A中的元素o，成功返回true（会先调用`contains`判断是否包含） |
| A.removeAll(C c)   | 移除集合   | **移除**集合A中**所有集合c中包含的元素**（移出交集）         |
| A.retain(C c)      | **交集**   | 将集合A与集合c的**交集赋给集合A**                            |
| A.toArray()        | 转换数组   | **生成**一个集合A包含元素组成的**数组**（相当于`Arrays.asList()`逆方法） |
| A.iterator()       | **迭代器** | 生成集合A的一个`Iterator`对象用于迭代遍历                    |

因大多数方法将调用`equals()`方法，因此最好将添加入集合中的自定义类重写此方法



### 1.1 集合数组相互转换

+ 调用集合方法`A.toArray()`可以将集合转换为**包含其全部元素**的数组
+ 调用数组方法`Arrays.asList(a)`可以将数组转换为包含其全部元素的`List`集合

### 1.2 迭代遍历Iterator

`Iterator`即迭代器，用于在不涉及实际对象细节的情况下去遍历操作该对象包含的属性和元素

**迭代器并不保存数据，实际上操作的还是元对象**，类似于一个**指针**，从原始对象的**头部之上**直到尾部

| 方法        | 含义       | 描述                                                         |
| ----------- | ---------- | ------------------------------------------------------------ |
| I.hasNext() | 是否还有   | **判断**该迭代器**是否已经到迭代完成**（是否还有下一个元素） |
| I.next()    | 获取下一个 | 按顺序**获取下一个位置的对象**                               |
| I.remove()  | 移除       | **移除原始集合中当前位置**的元素                             |

### 1.3 foreach

使用`for(O o:c)`的增强`for`循环可以自动调用`iterator`迭代器去迭代**集合或数组**中的对象

```java
      for(Object o:collection){
            System.out.println(o);
        }
```

注意若是`String`和`LocalDate`以及基本数据类型，因其**不可变性**`foreach`指向的**并不是原有**数组或集合中的**对象**



## 2. List

`List`用来存储**有序**、**可重复**的**单组数据集**的**接口**，有以下**实现类**：

| 实现类     | 名称     | 描述                                                     |
| ---------- | -------- | -------------------------------------------------------- |
| ArrayList  | 数组集合 | 线程不安全，高效率，底层是Object[]，使用**数组顺序存储** |
| LinkedList | 链表集合 | 底层是**双向链表**（当**中间插入删除频繁时效率更高**）   |
| Vector     | 矢量集合 | 线程安全，但效率低，底层是Object[]，使用**数组顺序存储** |

+ 链表存储：使用指针指向前后的元素，当**插入或删除时只需要改变指针指向**即可，但**查询效率低下**
+ 顺序存储：使用相连的整块内存，查询时可以按顺序遍历，但**插入和删除时需要改变之后所有元素的位置**

### 2.1 ArrayList

`ArrayList`是`List`接口最常用的构造器，其底层使用**数组**的方式进行实现

#### 2.1.1 构造器

当调用其空参构造器`new ArrayList()`时，会将其中的数组**默认初始化长度为10**，带参构造器会将数组长度**默认为参数长度**。

在`JDK8`中，其空参构造器不再初始化数组，当**第一次调用添加**方法时**才将数组初始化长度10**。

#### 2.1.2 添加

当调用`add()`方法进行添加时，会实现调用内部`ensureCapacityInternal(size+1)`来**判断数组容量是否充足**。

#### 2.1.3 动态扩容

当容量不够时会调用内部方法`grow()`，有三种扩容方式：（若原始长度为size，添加后需要长度为need）

+ 当第一次扩容时会将数组容量**增加为原先的1.5倍**（1.5*size)
+ 若扩容一次后依然不足以添加会**直接将长度扩容为所需要的长度**（need）
+ 当需求长度接近某个阈值时，会直接设置为`int`类型最大值`Integer.MAX_VALUE`



### 2.2 LinkedList

`LinkedList`是`List`使用**双向链表**的一个实现类，当进行**中间插入和删除时效率更高**，但**随机存取效率低下**，其内部使用内部类`Node`来存储存入的数据，并记录头尾地址。



### 2.3 Vector

`Vector`是`List`接口未出现时就存在的`Collection`实现类，后续被归入`List`接口实现类，其具体实现除扩容外（**其扩容方式默认是扩容为原来的2倍**）同`ArrayList`相似，但其所有方法均是由`sychronized`声明的**同步方法**，因此具有**线程安全性**，但执行效率低下。



### 2.4 常用方法

因其是顺序的`Collection`实现类，因此其中添加了部分方法

| 方法                   | 含义       | 描述                                                         |
| ---------------------- | ---------- | ------------------------------------------------------------ |
| A.add(int i,O o)       | 插入       | 在集合A的i位置**插入**元素o（之后元素依次后移）              |
| A.addAll(int i,C c)    | 插入全部   | 在集合A的i位置**插入集合c的全部元素**                        |
| A.get(int i)           | 获取       | **获取**集合A**指定位置**i的存储的元素                       |
| A.indexOf(O o)         | 首位置索引 | 获取元素o在集合A中的**首次**出现**位置索引**（不存在返回-1） |
| A.lastIndexOf(O o)     | 末位置索引 | 获取元素o在集合A中**最后一次**出现的**位置索引**（不存在返回-1） |
| A.remove(int i)        | 移除       | 移除集合A中指定位置i的元素**并将其返回**（`collection`的方法重载） |
| A.set(int i,O o)       | 设置       | 将集合A中指定位置i的元素**修改**为o                          |
| A.subList(int s,int e) | 截取子集   | **生成**一个集合A的**[s,e)的子集**                           |

+ 若`List`存储的整数（包装类），调用`remove(int i)`方法时**默认是索引移除**，**若要调用`Collection`的方法需要显示传入包装类**



## 3. Set

`Set`是`Collection`的一种**无序**，**不可重复**的**单列集合**接口，具有以下实现类：

| 实现类        | 含义            | 描述                                                         |
| ------------- | --------------- | ------------------------------------------------------------ |
| HashSet       | 哈希SET         | 采用HashMap的方式存储，**线程不安全**，**可以存储null**      |
| LinkedHashSet | Link**哈希SET** | HashSet的**子类**，可以按照**添加顺序遍历**，频繁**遍历效率更高** |
| TreeSet       | 树Set           | 采用**红黑树**方式存储，可以按照指定属性**排序**（必须是同一类型） |

+ 无序是指在内存中存储的顺序**不是顺序索引**而是**按照哈希值索引**
+ 不可重复指的按照`equals`判断不能返回`true`，**相同的元素只能存在一个**（采用Hash判断）



### 3.1 HashSet

#### 3.1.1 构造器

`HashSet`无参构造器，默认会构造一个**长度为16的数组**（底层采用的是**HashMap方法存储**）

#### 3.1.2 添加

当调用`add()`方法时，若是第一次添加先**计算其Hash值**、并通过内部**散列函数**获取索引位置，并**存储在数组的索引位置**。

当非第一次添加时，调用元素`HashCode()`计算Hash值和索引位置，若索引位置**已经存在**元素（或链表），**对Hash值进行比较**：

+ 若不等，这以**链表**的方式在**该位置存储**元素，并**连接在**之前存在元素的**后方**（JDK在前方）
+ 若相同，则比较`equals`，若返回**`true`则添加失败**，否则**`false`使用链表连接在后**



### 3.2 LinkedHashSet

`LinkedHashSet`是`HashSet`的子类，其所有结构与方法与`HashSet`相同，仅仅在**每个元素之间多加了一个指针按照添加顺序进行指向**，相当于在`HashSet`同位置单链表的基础上修改为**双链表**，当**频繁遍历时效率更高**。



### 3.3 TreeSet

`TreeSet`其存储方式使用**红黑树**。存储的数据必须是相同类的对象（**包括子类，实现类**），且**实现`Comparable`接口或者自定义`Comparator`**，其会自动将其添加的数据进行比较排序，迭代时将会**按照排列顺序输出**。

其判断元素是否相同采用的是比较大小，**若相同（返回0）则添加失败**（红黑树二叉树性质决定）

#### 3.3.1 构造器

`TreeSet`无参构造器构造后，将使用元素的**`ComparaTo()`方法进行比较**（必须实现`Comparable`方法，否则抛出异常）

`TreeSet`单参构造器，需要**传入参数`Comparator`自定义比较器**，添加元素将使用自定义比较器比较。



# 三、Map接口

`Map`用来存储键值对模式具有映射关系的数据，主要有以下三个实现类（接口）

| 类/接口  | 含义           | 描述                                                         |
| -------- | -------------- | ------------------------------------------------------------ |
| HashMap  | **哈希映射表** | 线程不安全，高效率，**key-value均可为null**，底层为**数组+链表+红黑树** |
| TreeMap  | **树映射表**   | 可以保证存储数据自动**按照`key`进行排序**，底层为**红黑树**  |
| Hashtabl | 哈希表         | 1.0存在的实现类，线程安全，单效率低，不能存储null            |

+ `HashMap`具有子类`LinkedHashMap`，其可以在遍历时按照添加顺序（实现方式同LinkedHashSet，采用双链表），**当频繁遍历时效率更高**
+ `Hashtabl`具有子类`Properties`主要用来处理配置文件，其**key-value均为`String`**

