# 一、EDT与线程安全

## EDT和EQ的理解

即UI（用户接口）处理界面相关与用户的接口的事件，非UI事件由后台的线程处理

**Event Dispatch Thread，事件派发线程**，由Java自动创建，它用来**监听Toolkit线程的事件，并派发给相应的监听器**，同时更新**UI界面**，其是一个**单线程规范**，如果运行耗时操作会导致UI界面卡住：

### EDT特性：

1. 监听ToolKit线程的事件，派发给监听器
2. 绘制UI界面
3. 单线程，线程不安全

在EDT中运用**事件队列（Event Queue)**,在线程非安全的基础上来保证单线程上的执行顺序，使各种操作按照先后顺序**串行执行**

### EQ要点：

1. 将同步转换为异步（EDT将耗时操作派发给异步后台线程）
2. 将并行转换为串行（EQ将各种UI操作按顺序交给EDT）

这一点同安卓中的**UIT（UI线程）**类似，即系统对每一个组件的调用都从UI线程分发出去，此外系统给出了`SwingUtilities`类中的静态方法来直接修改EDT中的EQ顺序

### SwingUtilities操作EDT要点

1. `SwingUtilities.invokeAndWait()` 用于同步调用EDT，即阻塞当前EDT并同步执行该方法
2. `SwingUtilities.invokeLater()`用于在EDT队列尾部插入当前线程，并等待异步执行
3. `SwingUtilities.isEventDispatchThread()`用于判断当前线程是否是EDT线程



## SwingWorker实现线程安全

使用SwingWorker可以来**创建一个后台处理线程，并在完成时通知EDT来更新UI界面**，同时还可以返回结果，这是一个抽象类，必须要重写抽象方法`doInbackGround()`方法，在其中执行耗时操作，然后通过重写调用`done()`方法，在完成时通知EDT将其排在EQ对尾，准备更新UI，其中可以通过`publish`和`process`来传递和处理中间数据

要点：

1. doInbackGround()，是后台执行的操作
2. done()，是执行完成后需要对UI做出的修改操作，这将在EDT上执行
3. execute()，执行当前SwingWorker

类比，这同安卓中的`AsyncTask`非常类似



# 二、Lookup模块解耦

`Lookup`是`netBeans Platform`中的一个组件，主要使用`Lookup.getDefault(Class)`来依赖查找相关接口的实现类，对模块进行解耦操作，实现对包含注解`@ServiceProvider`的接口实现**依赖查找（DL）**和**控制反转（IoC）**

1. **控制反转 Inversion of Control （IoC）**：不需要手动显示new对象，而是通过外部容器将所需要的依赖生成，即将程序内部的依赖转换为对外部容器的依赖，主要用DI和DL两种方式实现
2. **依赖注入 Dependency Injection（DI）** ：完全依靠容器进行自动注入，在启动时就生成相应的依赖对象，需要使用时进行注入
3. **依赖查找 Dependency Lookup  （DL）**：调用容器的API（例如Lookup方法）通知容器查找生成依赖对象

利用容器的API传入指定的Class实现类，实现对模块的解耦和反转控制





# 三、MVC三层结构

要点：

1. **利用dataModel保存非UI数据**，使得数据与界面解耦，将具体的逻辑交给具体的模型
2. 利用良好的封装和继承，只需要在相应的ExtraHandle中重写对应的方法即可完成对组件的定制
3. 体现开闭原则

涉及知识点：

1. **MVC思想**：Model、View、Control ，即数据、界面、控制相互分离解耦，
   1. V视图层仅仅只是做数据的展示和用户交互
   2. M模型层用来保存传递数据和显示规则以及同后端的接口
   3. C控制层根据用户的响应来控制调用相应的Model去处理数据和事件，做V与M的桥梁



# 四、map、list缓存机制与引用类型

1. 创建一个Map单例，将需要使用的对象用键值对的形式缓存到内存中，需要使用时候通过Key进行读取，典型案例：
   1. session，Map<key,Map<Key,Values>
   2. Attribute,Map<Key,Values>
   3. WeakHashMap是一种弱引用类型，当内存不足时会回收，如果有正在引用的会转换为hashMap
   
2. 创建List的序列号类，使用下标索引的方式写入list中，并序列化到文件，需要使用时从文件读取

3. JAVA中包含 **强引用**、**软引用**、**弱引用**、**虚引用** 四种类型

   1. **强引用**：直接显示new 的对象都是强引用，只要对象还在引用，JVM即使抛出OOM(内存溢出)也不会回收
   2. **软引用**：仅次于强引用，仅当JVM即将内存不足时，才会回收，回收前可以用get方法转换为强引用
   3. **弱引用**:   如果声明为若引用，一旦执行gc时就会被回收
   4. **虚引用**：如果声明虚引用，一旦JVM扫描到就会回收，需要加入引用队列中使用，可以判断是否回收

   

# 五、事务机制**Transaction**

ACID是**原子性（atomicity）**、**一致性（consistency）**、**隔离性 （isolation）和持久性（durability）**

1. 事务的原子性：表示事务执行过程中的任何失败都将导致事务所做的任何修改失效。
2. 事务的一致性：表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。
3. 事务的隔离性：表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。
4. 事务的持久性：表示已提交的数据在事务执行失败时，数据的状态都应该正确。

**要么全部执行成功，要么撤销不执行**

`setAutoCommit()`取消自动事务，`rollback`回滚，`commit`提交，`SavePoit`设置保存到

除了JDBC事务，还有**容器事务**、**JTA事务**



# 六、网络协议

| OSI 模型   | TCP/IP模型 | 作用                         | 例子                  |
| ---------- | ---------- | ---------------------------- | --------------------- |
| 物理层     | 网络接口层 | 物理硬件                     | 光纤、WLAN、双绞线    |
| 数据链路层 |            | 提供介质和链路的管理（网卡） | 网卡                  |
| 网络层     | 网际层     | IP和路由的选择               | Ipv4、Ipv6、ARP、ICMP |
| 传输层     | 传输层     | 建立、管理设备到设备的连接   | TCP、UDP              |
| 会话层     | 应用层     | 建立连接会话                 | HTTP/S、FTP、SMTP     |
| 表示层     |            | 数据格式化、加密             |                       |
| 应用层     |            | 应用使用                     |                       |



# 七、事件监听

**事件**即发生的某一个动作，其必要有一个事件发生源头，**事件监听**是对某一特定动作而做出的响应

一个事件三要素为：**事件源头**、**事件动作**、**事件的消息（包括事件发生时间）**

并且当事件发生时，所有对此事件进行监听的对象都能收到消息

包含对象为：

1. **Even事件**，可以是一个接口，包含必要的信息，包括事件应该发生的事情和当前事件包含的消息
2. **Listener监听器**：事件监听器应该包含事件发生后的响应，已经对事件的操作，需要首先获取信息，因此事件要作为其参数，并有一个回调方法来响应事件
3. **Source事件源**：事件源头是一个事件发生的地方，应该包含设置相应事件监听器的方法，以及在达成触发事件条件时，生成一个事件，并将其传递给监听器，并执行监听器中的回调方法

与观察者模式的区别在于，**在观察者模式中并没有Event事件对象，具体的动作由Observable被动了解，事件监听模式中由事件源头主动通知监听器**



# 八、消息队列Message Queue

将一对多的单向依赖转换为消息传播出去，即消息**生产者**，需要依赖组件按照消息产生的顺序按照**FIFO先进先出（队列Queue）**原则做出对消息的响应，即消息**消费者**

将一对多的依赖转换为 **生产者产生信息-->消息队列MQ-->消费者响应信息**  的中间件依赖，实现了各个组件的**解耦**，将事务中的顺序执行，转换为  **主要事务-->消息队列-->完成主要业务    消息队列-->其他事务**  的**异步执行**形式，提高了主要业务的响应速度和可靠性，并且业务FIFO的形式，次要业务可以根据自身情况对队列进行限流消费，实现类对高并发情况下的**延时削峰**

主要作用：**解耦**、**异步**、**削峰**

与事件队列（EventQueue）的区别：因为Swing大多数的非线程安全，EDT为了保证在单线程上同UI界面的可靠绘制使用事件队列将并行的界面更新转换为串行的同步绘制，将同步的耗时响应派发给监听器进行异步执行，是一种在非安全单线程下尽可能保证线程安全的解决方案。