# 一.基本数据

## 1.八大基本数据类型

### 1.1 整形

| 类型  | 占用                | 范围                |
| ----- | ------------------- | ------------------- |
| byte  | 1byte字节=8二进制位 | -128~127            |
| short | 2byte               | -2^15~2^15-1（3W)   |
| int   | 4byte               | -2^31~2^31-1（21E） |
| long  | 8byte(**需要带L**)  | -2^63~2^63-1        |

**当long声明不叫L时候，会默认为int并将其赋值为long**

**二进制第一位为符号位，0位负数，1正数**

### 1.2 浮点型

| 类型         | 占用  | 范围                 |
| ------------ | ----- | -------------------- |
| 单精度float  | 4byte | -3.403E38~3.408E38   |
| 双精度double | 8byte | -1.798E308~1.798E308 |

**默认位double，float后需要加f/F**

### 1.3 字符类型

**1Char=2byte**，`char c='A'` 声明方式，可以使用转义字符

> \n 换行 \t 制表(tab) \为转义
>
> 在ASCII中 A==65  a==97

同时支持Unicode，例如`'\u0043'=='C'`，**char必须''中由字符，空必须为空格，否则为报错**

### 1.4 boolean类型

只能是`true`或`false` （C类语言中0是false 非0位true）



## 2. 类型转换

除boolean外的7种基本数据类型可以进行类型转换

### 2.1 自动类型转换

+ **范围小的类型可以自动向更大范围的类型进行转换** （指定的表示数范围大小，非内存大小）

+ **整型可以自动向浮点型转换**
+ **byte、short、char<int<long<float<double**
+ byte、short、char**进行运算，或自身运算结果均为int**

### 2.2 强制类型转换

与自动类型转换相逆的转换，其会损失精度，自动丢失大范围的存储，导致精读损失**（仅截取后面符合内存的位）**

+ 小范围类型的最大范围+1转换后为小范围最小（二进制溢出）
+ float声明必须f，否则为double强转报错
+ **单独的数字（常量），默认均为int或double**



## 3. String字符串（不可变引用）

+ **String由一组（可空）的char组成**，声明使用`""`
+ **可以和8中基本数据类型做连接运行(+)**
+ 连接运算结果均为String
+ String**右边的所有+均为连接**，**左边按照原有含有运算**
+ 存储在方法区常量池中



## 4. 常用进制

| 进制            | 表示            | 声明           |
| --------------- | --------------- | -------------- |
| 二进制(binary)  | 0\1 满2进1      | **0b或0B开头** |
| 十进制(decimal) | 0-9 满10进1     | **直接写数**   |
| 八进制(octal)   | 0-7 满7进1      | **0开头**      |
| 十六进制(hex)   | 0-9 A-F 满15进1 | **0x开头**     |



## 5. 二进制原码、补码、反码

| 内容              | 含义                                 | 案例        |
| ----------------- | ------------------------------------ | ----------- |
| 十进制            | 14                                   | 14          |
| 14二进制（1byte)  | 8位，第一位位符号位，0位正数1为负数  | 00 00 11 10 |
| -14二进制（1byte) | -14                                  | 10 00 11 10 |
| -14原码           | 二进制本身                           | 10 00 11 10 |
| -14反码           | **除了符号位**全部取反（0->1，1->0） | 11 11 00 01 |
| -14补码           | 在反码的基础上加1**(反码+1)**        | 11 11 00 10 |

+ **计算机底层以补码的形式存储数据**
+ **补码、反码仅用于负数，正数存储的是原码**
+ 基本数据类型是直接存储在栈空间中

# 二、基础运算

## 1. 算术运算符

| 运算 | 运算符 | 案例 | 结果 |
| ------ | ---- | ---- | ---- |
| 正号   | +A | +1 | 1 |
| 负号   | -A | -1 | -1 |
| 加     | A+B | 1+2 | 3 |
| 减     | A-B | 1-2 | -1 |
| 乘     | A*B | 2*3 | 6 |
| 除     | A/B | 4/2 | 2 |
| 取模   | A%B | 3%2 | 1 |
| 前自加(先自加后运算) | ++A | a=1;b=++a | a=2;b=2 |
| 后自加(先运算后自加) | A++ | a=1;b=a++ | a=2;b=1 |
| 前自减(先自减后运算) | --A | a=2;b=--a | a=1;b=1 |
| 后自减(先运算后自减) | A-- | a=2;b=a-- | a=1;b=2 |
| 连接 | "A"+B | "2"+5 | "25" |

**整型除法结果位整型，需要强转，若加（）需要先在（）中转型**

### ++a和a++

1. `++a` 先执行 a=a+1，再执行其他；

   例如 a=1, b=0  b=++a;则**b=2,a=2**

2. `a++`先执行其他，再执行a=a+1;

   例如 a=1, b=0  b=a++;则**b=1,a=2**

   **自加\减法 不会改变原有类型**



## 2. 赋值运算符

| 运算  | 运算符 | 案例     | 结果 |
| ----- | ------ | -------- | ---- |
| 赋值  | =      | int A=20 | 20   |
| +赋值 | +=     | A+=10    | 30   |
| -赋值 | -=     | A-=10    | 20   |
| *赋值 | *=     | A*=10    | 200  |
| /赋值 | /=     | A/=10    | 20   |
| %赋值 | %=     | A%=10    | 0    |

**基本数据类型赋值是直接将值赋值给另一个，引用数据类型地址赋值**

**运算赋值不会改变原有类型**

```java
short a=10;
a=a+2;  // 错误  2为int
a+=2; // 通过 不会改变原有类型
```



## 3. 比较运算符

| 运算              | 运算符     | 案例                 | 结果  |
| ----------------- | ---------- | -------------------- | ----- |
| 相等              | ==         | 4==3                 | false |
| 不等于            | !=         | 4!=3                 | true  |
| 大于              | >          | 5>6                  | false |
| 小于              | <          | 5<6                  | true  |
| 大于等于          | >=         | 5>=6                 | false |
| 小于等于          | <=         | 5<=6                 | true  |
| 是否是类/子类对象 | instanceof | "" instanceof String | true  |



## 4. 逻辑运算符

**逻辑运算符对boolean运算时是逻辑运算**

| 运算     | 运算符 | 含义                        | 结果               |
| -------- | ------ | --------------------------- | ------------------ |
| 逻辑与   | A&B    | AB均为true为true            | true&true=true     |
| 逻辑或   | A\|B   | A或B有一个为true为true      | true\|flase=true   |
| 逻辑非   | !A     | A为false为true              | !fasle=true        |
| 短路与   | A&&B   | 同与，若A为false则不再判断B | true&&true=true    |
| 短路或   | A\|\|B | 同或，若A为true则不再判断B  | true\|\|false=true |
| 逻辑异或 | A^B    | AB不相同时为true            | true^true=false    |

 

## 5. 三元运算符

**（boolean表达式F）？A:B** ，若F为true则执行A，否则执行B

+ **三元运算符可以和if-else相互转换**
+ 三元运算符冒**号两边若是基本类型要一致，否则会自动类型转换**



## 6. 位运算符

**位运算符对数字运算时是位运算，否则为逻辑运算**

**位运算时间复杂度最低，位常量1**

| 运算       | 运算符 | 含义                                                         | 结果                     |
| ---------- | ------ | ------------------------------------------------------------ | ------------------------ |
| 左移       | A<<B   | 将A的二进制位向左移动B位，**在A右边补B个0后取bit位内的数**，相当于A*(2^B) | 2>>2=2*4=8               |
| 右移       | A>>B   | 将A的二进制位向右移动B位，**在A左边补B个0/1后取bit位内的数**，相当于A/(2^B)，最高位为0就补0否则补1 | 9<<3=9/8=1               |
| 无符号右移 | A>>>B  | 将A的二进制位）向右移动B位，**在A左边补B个0后取bit位内的数** | 21<<27=负数;21<<<27=正数 |
| 按位与     | A&B    | 对二进制位进行运算，运算时1=true 0=false，逐位取&            | 6&3=2                    |
| 按位或     | A\|B   | 对二进制位进行运算，运算时1=true 0=false，逐位取\|           | 6\|3=7                   |
| 异或       | A^B    | 对二进制位进行运算，运算时1=true 0=false，逐位取^            | 6^3=5                    |
| 取反       | ~A     | 包括符号位之内，0->1,1->0                                    | ~6=-1;~-1=6              |

### 6.1 &按位与

二进制位都为1取1，否则取0

**0101&1100=0100；**

### 6.2 |按位或

二进制位有1则取1，否则取0

**0101 | 1100=1101；**

### 6.3 ^异或

二进制位相同为0，不同为1

**0101 ^ 1100=1001；**

### 6.4 ~取反

`（加一取-）`

~-3=2；~2=-3；

### 6.5 <<左移

二进制位整体向左行动N位，多余部分舍弃；

0011<<2=1100;  1011<<2=1100;

### 6.6 >>右移

二进制位整体向右移动N位，空缺部分正数填0，负数填1；

1100>>2=0011;

**其中>>>是不带符号移动**,都填0



## 7. 交互变量运算

### 7.1 临时变量法

引入第三方临时变量，用内存空间来交互

```java
int a=10,b=20;
int t=a;
a=b;
b=t;
```

### 7.2 相加相减法

利用数值空间交互，节省内存空间，**若数值过大有溢出风险，且只能用于数值**

```java
int a=10,b=20;
a=a+b;
b=a-b;
a=a-b;
```

### 7.3 位运算法

两个数异或以后会变为一个数K，K异或其中任意一个会变为另一个（01交互）

```java
int a=10,b=20;
a=a^b;
b=a^b;
a=a^b;
```



# 三、程序结构

## 1. 分支机构

switch都可以用if-else替代，反之不可，**但switch执行效率更高**

### 1.1 if-else

```java
if(BA){
    
}else {
    
}

if(BB){
    
}

if(BC){
    
}else if(BC2){
    
}else{
    
}
```



### 1.2 Switch-case-default

```java
switch(X){
    case A:FA;
    case B:FB;break;
    case C:FC;break;
    default:FD;break;
}
```

**其中X只能为如下六种数据类型：**

+ `byte`、`short`、`int`
+ `char`、`String`（JDK7）
+ `枚举enum`（JDK5）

Switch只是判断X和case后的ABCD是否相等（前提是类型相同，**因此不能使用条件表达式，只能使用常量**），同时`default`可以在任意位置，不一定在最后



## 2. 循环结构

循环结构四要素

+ ①初始条件
+ ②循环条件
+ ③迭代条件
+ ④循环体

其中只有**②循环条件是必须的**

### 2.1  for

```java
for(①;②;③){
④;
}
```

①->②true->④->③->②true->④->③->②true->...

**①->②false->break;**

### 2.2 while

```java
①;
while(②){
 ④;
 ③;
}
```

①->②true->④->③->②true->④->③->②true->...

**①->②false->break;**

**for和while可以相互转换，执行顺序完全等价，区别为for中的①只在for内生效**

### 2.3 do-while

```java
①；
do{
    ④;
    ③；
}while(②)
```

①->④->③->②true->④->③->②true->....

**①->④->③->②false->break;**

do-while**至少会执行一次循环**



## 3. 嵌套循环

**一般情况下嵌套循环不会超过三层，此时时间复杂度已经变成o立方**



## 4. 跳出结构

`break`和`continue`后不可以有其他语句，**默认跳出最近的包裹循环**

### 4.1 break

**结束当前循环，直接跳出当前的循环**

### 4.2 continue

**结束当前循环，仅跳过当前的这一次循环体**

### 4.3 标签跳出

在循环结构前加上自定义标签，在跳出关键字前加上相应的标签，可以跳出指定循环，如下使用标签求质数。

```java
public class Label{
	public static void main(String... args){
		int count=0;
		out: for(int i=2;i<=100000;i++){
			for(int j=2;j<=Math.sqrt(i);j++){
				if(i%j==0)
					continue out;
				count++;
			}
		}
		System.out.println("sum="+count);
	}
}
```



# 四、引用/对象类型

## 1. 数组

| 声明方式                   | 声明                                      |
| -------------------------- | ----------------------------------------- |
| 声明                       | X[] x;                                    |
| 动态初始化（声明并初始化） | X[] x=new X[n]                            |
| 静态初始化（声明并赋值）   | X[] x=new X[]{A,B,C,D}<br>X[] x={A,B,C,D} |

1. **数组一经初始化，大小就无法改变，若需改变只能重新声明**
2. **数组是内存中的一段连续空间（1的原因）**
3. **脚标从X[0]开始，X[n-1]结束**
4. 打印输出Char[]数组时，会自动组合成一个String输出，其他会输出地址。

### 1.1 数组默认初始化值

+ **整型默认为0(byte、short、int、long）**
+ **浮点型默认为0.0（float、double)**
+ **Char默认为ASCII为0（char  a=0;非'0',显示为' '但非空格）**
+ **boolaen为false（二进制0）**
+ **引用类型（对象）默认为null**

### 1.2 数组内存分析

[内存分析](./JAVA5-内存分析.md)

### 1.3 多维数组

**多维数组就是在数组的每一个元素也是数组**

| 声明方式                   | 声明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 声明                       | `X[][]`                                                      |
| 动态初始化（声明并初始化） | `X[][]` x=new `X[n][]`<br>`X[][]` x=new `X[n][m]`            |
| 静态初始化（声明并赋值）   | `X[][]` x=new `X[][]`{{A,B,C},{D,E},{F}}<br>`X[][]` x={{A,B,C},{D,E},{F}} |

### 1.4 数组常用方法

使用new进行复制

```java
X[] x=new X[old.length];
for(int i=0;i<old.length;i++){
	 x[i]=old[i];
}
```

使用取反进行交互

```java
 for(int i=0;i<old.length/2;i++){
           X temp=old[i]; 
     old[i]=old[old.length-1-i];
     old[old.length-1-i]=temp;
        }
```

**数组常用类库为Arrays，其中已经封装了相关方法**[常用类库](./JAVA5-基础03-常用类库.md)



## 2. 类

参见第二篇：面向对象

## 3. 接口

参见第二篇：面向对象



# 五、Main方法

1、main()是程序的入口

2、main()也是一个普通的静态方法，没有返回值

3、该方法作为入口时，是JVM虚拟机调用，因此必须是public

4、main()方法也可以使用参数与程序进行交互，可以使用参数对其进行赋值

## 1. Main 交互

`java (主类名)` 运行**（注意没有.class后缀名）**

**在主类名后空格可以加入多个参数**（可省`""`），将赋值给main()方法

```shell
java MainDome "2" "22" "dome"
```

